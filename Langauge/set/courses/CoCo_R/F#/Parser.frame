(*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*)

-->begin
-->namespace

open System;
open System.IO;
open System.Collections.Generic;
open Scanner;


type Errors =
class
val mutable count:int
val mutable errorStream:System.IO.TextWriter
val mutable errMsgFormat:string


	new() = {
		count=0;
		errorStream = Console.Out;
		errMsgFormat = "-- line {0} col {1}: {2}"; //0->line, 1->column, 2->text
	}
	
	member x.SynErr ((line:int), (col:int), (n:int)) =
		let s = 
		match n with
-->errors
			| _ -> "error " ^ (string_of_int n)
		in
			x.errorStream.WriteLine(x.errMsgFormat,line,col,s);
			x.count<- x.count+1;
	

	member x.SemErr ((line:int), (col:int), (s:string)) =
		x.errorStream.WriteLine(x.errMsgFormat,line,col,s);
		x.count<- x.count+1;
	

	member x.SemErr (s:string) =
		x.errorStream.WriteLine(s);
		x.count<- x.count+1;
	
	member x.Warning((line:int), (col:int), (s:string)) =
		x.errorStream.WriteLine(x.errMsgFormat,line,col,s);
		
	
	member x.Warning(s:string) =
		x.errorStream.WriteLine(s);
	
end // Errors


type parser =
class
-->constants1
	val T:bool;
	val x:bool;
	val minErrDist:int;
	val mutable scanner:scanner;
	val mutable errors:Errors;
	val mutable t:Token; //last recognized token
	val mutable la:Token; //lookahead token
	val mutable errDist:int;
-->variables


	new(scan:scanner)= {
-->initvariables
-->constants2 //initialization of the constants
		scanner =  scan;
		T=true;
		x=false;
		minErrDist=2;
		errors= new Errors();
		t= new Token (0,0,0,0,"dummy",None);
		la= new Token (0,0,0,0,"dummy",None);
		errDist=2;
	}

-->declarations
	member x.SynErr(n:int) = 
		if (x.errDist >= x.minErrDist) then x.errors.SynErr(x.la.line, x.la.col, n);
		x.errDist <- 0;
	

	member x.SemErr(msg:string) =
		if (x.errDist >= x.minErrDist) then x.errors.SemErr(x.t.line, x.t.col, msg);
		x.errDist <- 0;
	
	
	member x.Get() =
		let bboll = ref true in
		while !bboll do
			x.t <- x.la;
			x.la <-x.scanner.Scan();
			if(x.la.kind <= x.maxT)
			then(
				x.errDist <- x.errDist +1;
				bboll:=false;
			);
			-->pragmas
			if(!bboll) then x.la <- x.t;
		done;
	
	
	
	member x.Expect (n:int) =
		if (x.la.kind = n) then x.Get() else  x.SynErr(n); 
	
	
	member x.StartOf (s:int) = x.set(s, (x.la.kind))
	
	
		member x.ExpectWeak ((n:int), (follow:int) ) =
		if (x.la.kind = n) then x.Get()
		else (
			x.SynErr(n);
			while (not(x.StartOf(follow)))do x.Get(); done;
		)
	
	
	member x.WeakSeparator((n:int), (syFol:int), (repFol:int)) =
		let kind = ref x.la.kind in
		if (!kind = n) then ( x.Get(); true )
		else 
			if (x.StartOf(repFol)) then false
			else(
				x.SynErr(n);
				while(not(x.set(syFol, !kind) || x.set(repFol, !kind) || x.set(0, !kind))) do 
					x.Get(); 
					kind:= x.la.kind;
				done;
				x.StartOf(syFol);
			)
	
	
	
-->productions

	member x.Parse() =
		x.la <- new Token (0,0,0,0,"dummy",None);
		x.Get();
-->parseRoot
		x.Expect(0);
	
	
	member x.Find((n:int), (bf:bool array) ) =
		try
			let t =	(bf.GetValue(Int64.of_int n):?>bool) in
			t
		with _ -> false
	
	
	member x.set((a:int),(b:int))= 
		match a with
-->initialization
		|_ -> false

end

$$$